import React, { useState, useEffect, useCallback } from "react";
import { Html5QrcodeScanner } from "html5-qrcode";
import QRCode from "react-qr-code";
import Dashboard from "./dashboard";

// --- STYLES (Mobile-First & Responsive) ---
const styles = `
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

body { 
    font-family: 'Inter', sans-serif; 
    background-color: #f3f4f6; 
    margin: 0;
    padding: 1rem;
}
/* ... (rest of the styles are the same) ... */
.container { max-width: 900px; margin: 0 auto; padding: 1.5rem; background-color: #ffffff; border-radius: 16px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05); }
.header { text-align: center; margin-bottom: 2rem; }
.title { font-size: 2.2rem; font-weight: 700; color: #111827; }
.description { color: #4b5563; margin-top: 0.5rem; font-size: 1rem; }
.top-bar { display: flex; flex-direction: column; gap: 1rem; margin-bottom: 2rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 1.5rem; }
.role-selector, .nav-buttons { display: flex; justify-content: center; gap: 0.5rem; flex-wrap: wrap; }
.role-button, .nav-button { background-color: #e5e7eb; color: #374151; border: none; padding: 12px 20px; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; }
.role-button:hover, .nav-button:hover:not(.active) { background-color: #d1d5db; }
.nav-button.active { background-color: #2563eb; color: white; box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2); }
.lang-select { padding: 10px; border-radius: 8px; border: 1px solid #d1d5db; font-family: 'Inter', sans-serif; font-weight: 500; align-self: center; }
.form-container { padding: 1.5rem; border: 1px solid #e5e7eb; border-radius: 8px; }
.form-container h2 { font-size: 1.5rem; font-weight: 600; margin-bottom: 1.5rem; color: #111827; text-align: center; }
.input-field, .select-field { width: 100%; padding: 12px; margin-bottom: 1rem; border-radius: 8px; border: 1px solid #d1d5db; font-size: 16px; box-sizing: border-box; }
.submit-button { background-color: #2563eb; color: white; border: none; padding: 14px 24px; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; width: 100%; }
.submit-button:disabled { opacity: 0.5; cursor: not-allowed; }
.status-message { margin-top: 1.5rem; font-weight: 500; text-align: center; padding: 1rem; border-radius: 8px; word-break: break-word; }
.status-success { background-color: #d1fae5; color: #065f46; }
.status-error { background-color: #fee2e2; color: #991b1b; }
.qr-section { margin-top: 2rem; padding: 1.5rem; border: 2px dashed #d1d5db; border-radius: 8px; text-align: center; }
.pending-list { list-style: none; padding: 0; }
.pending-item { background-color: #f9fafb; padding: 1rem; border-radius: 8px; margin-bottom: 0.5rem; border: 1px solid #e5e7eb; cursor: pointer; transition: background-color 0.2s; }
.pending-item:hover { background-color: #eff6ff; }
.pending-item span { font-size: 0.8rem; color: #6b7280; }
.refresh-button { background-color: #6b7280; margin-left: 1rem; }
.quality-score-display { text-align: center; font-size: 1.2rem; font-weight: 600; margin: 1.5rem 0; padding: 1rem; background-color: #eff6ff; border-radius: 8px; color: #1e40af; }
#qr-reader { width: 100%; max-width: 500px; margin: 0 auto; border: none; }

@media (min-width: 640px) {
    .top-bar { flex-direction: row; }
    .lang-select { align-self: auto; }
}
`;

// --- TRANSLATIONS ---
const translations = {
    en: { title: "DungTrace", farmer: "Farmer", collector: "Collector", owner: "Owner", addLoad: "Add New Load", scanFarmerQR: "Scan Farmer ID QR", weight: "Weight (KG)", createRecord: "Create Record", submitting: "Submitting...", pendingCollections: "Pending Collections", verifyBatch: "Verify Batch", qualityScore: "Calculated Quality Score", updateRecord: "Update Record", password: "Password", enter: "Enter", collectorName: "Collector's Name", refresh: "Refresh List", village: "Village", cowBreed: "Cow Breed", feedType: "Feed Type", moisture: "Moisture Level (%)", purity: "Purity Score (1-10)" },
    ta: { title: "роЪро╛рогроорпНродроЯроорпН", farmer: "ро╡ро┐ро╡роЪро╛ропро┐", collector: "роЪрпЗроХро░ро┐рокрпНрокро╛ро│ро░рпН", owner: "роЙро░ро┐роорпИропро╛ро│ро░рпН", addLoad: "рокрпБродро┐роп роЪрпБроорпИропрпИроЪрпН роЪрпЗро░рпНроХрпНроХро╡рпБроорпН", scanFarmerQR: "ро╡ро┐ро╡роЪро╛ропро┐ QR роР ро╕рпНроХрпЗройрпН роЪрпЖропрпНропро╡рпБроорпН", weight: "роОроЯрпИ (роХро┐ро▓рпЛ)", createRecord: "рокродро┐ро╡рпИ роЙро░рпБро╡ро╛роХрпНроХро╡рпБроорпН", submitting: "роЪрооро░рпНрокрпНрокро┐роХрпНроХрокрпНрокроЯрпБроХро┐ро▒родрпБ...", pendingCollections: "роиро┐ро▓рпБро╡рпИропро┐ро▓рпН роЙро│рпНро│ роЪрпЗроХро░ро┐рокрпНрокрпБроХро│рпН", verifyBatch: "родрпКроХрпБрокрпНрокрпИроЪрпН роЪро░ро┐рокро╛ро░рпНроХрпНроХро╡рпБроорпН", qualityScore: "роХрогроХрпНроХро┐роЯрокрпНрокроЯрпНроЯ родро░ роородро┐рокрпНрокрпЖрогрпН", updateRecord: "рокродро┐ро╡рпИрокрпН рокрпБродрпБрокрпНрокро┐роХрпНроХро╡рпБроорпН", password: "роХроЯро╡рпБроЪрпНроЪрпКро▓рпН", enter: "роЙро│рпНро│ро┐роЯро╡рпБроорпН", collectorName: "роЪрпЗроХро░ро┐рокрпНрокро╛ро│ро░рпН рокрпЖропро░рпН", refresh: "рокроЯрпНроЯро┐ропро▓рпИрокрпН рокрпБродрпБрокрпНрокро┐роХрпНроХро╡рпБроорпН", village: "роХро┐ро░ро╛роороорпН", cowBreed: "рооро╛роЯрпНроЯро┐ройрпН роЗройроорпН", feedType: "родрпАро╡рой ро╡роХрпИ", moisture: "роИро░рокрпНрокродроорпН (%)", purity: "родрпВропрпНроорпИ роородро┐рокрпНрокрпЖрогрпН (1-10)" },
    hi: { title: "рдбрдВрдЧрдЯреНрд░реЗрд╕", farmer: "рдХрд┐рд╕рд╛рди", collector: "рд╕рдВрдЧреНрд░рд╛рд╣рдХ", owner: "рдорд╛рд▓рд┐рдХ", addLoad: "рдирдпрд╛ рд▓реЛрдб рдЬреЛрдбрд╝реЗрдВ", scanFarmerQR: "рдХрд┐рд╕рд╛рди QR рд╕реНрдХреИрди рдХрд░реЗрдВ", weight: "рд╡рдЬрди (рдХрд┐рд▓реЛ)", createRecord: "рд░рд┐рдХреЙрд░реНрдб рдмрдирд╛рдПрдВ", submitting: "рднреЗрдЬ рд░рд╣рд╛ рд╣реИ...", pendingCollections: "рд▓рдВрдмрд┐рдд рд╕рдВрдЧреНрд░рд╣", verifyBatch: "рдмреИрдЪ рд╕рддреНрдпрд╛рдкрд┐рдд рдХрд░реЗрдВ", qualityScore: "рдЧрдгрдирд╛ рдЧреБрдгрд╡рддреНрддрд╛ рд╕реНрдХреЛрд░", updateRecord: "рд░рд┐рдХреЙрд░реНрдб рдЕрдкрдбреЗрдЯ рдХрд░реЗрдВ", password: "рдкрд╛рд╕рд╡рд░реНрдб", enter: "рджрд░реНрдЬ рдХрд░реЗрдВ", collectorName: "рд╕рдВрдЧреНрд░рд╛рд╣рдХ рдХрд╛ рдирд╛рдо", refresh: "рд╕реВрдЪреА рддрд╛рдЬрд╝рд╛ рдХрд░реЗрдВ", village: "рдЧрд╛рдВрд╡", cowBreed: "рдЧрд╛рдп рдХреА рдирд╕реНрд▓", feedType: "рдЪрд╛рд░рд╛ рдкреНрд░рдХрд╛рд░", moisture: "рдирдореА рд╕реНрддрд░ (%)", purity: "рд╢реБрджреНрдзрддрд╛ рд╕реНрдХреЛрд░ (1-10)" },
    te: { title: "р░бр░Вр░Чр▒НтАМр░Яр▒Нр░░р▒Зр░╕р▒Н", farmer: "р░░р▒Ир░др▒Б", collector: "р░╕р▒Зр░Хр░░р░┐р░Вр░Ър▒Зр░╡р░╛р░бр▒Б", owner: "р░пр░Ьр░ор░╛р░ир░┐", addLoad: "р░Хр▒Кр░др▒Нр░д р░▓р▒Лр░бр▒Н р░Ьр▒Лр░бр░┐р░Вр░Ър░Вр░бр░┐", scanFarmerQR: "р░░р▒Ир░др▒Б QR р░╕р▒Нр░Хр░╛р░ир▒Н р░Ър▒Зр░пр░Вр░бр░┐", weight: "р░мр░░р▒Бр░╡р▒Б (р░Хр░┐р░▓р▒Лр░▓р▒Б)", createRecord: "р░░р░┐р░Хр░╛р░░р▒Нр░бр▒Н р░╕р▒Гр░╖р▒Нр░Яр░┐р░Вр░Ър░Вр░бр░┐", submitting: "р░╕р░ор░░р▒Нр░кр░┐р░╕р▒Нр░др▒Лр░Вр░жр░┐...", pendingCollections: "р░кр▒Жр░Вр░бр░┐р░Вр░Чр▒Н р░╕р▒Зр░Хр░░р░гр░▓р▒Б", verifyBatch: "р░мр▒Нр░пр░╛р░Ър▒НтАМр░ир▒Б р░зр▒Гр░╡р▒Ар░Хр░░р░┐р░Вр░Ър░Вр░бр░┐", qualityScore: "р░▓р▒Жр░Хр▒Нр░Хр░┐р░Вр░Ър░┐р░и р░ир░╛р░гр▒Нр░пр░д р░╕р▒Нр░Хр▒Лр░░р▒Б", updateRecord: "р░░р░┐р░Хр░╛р░░р▒Нр░бр▒Н р░ир░╡р▒Ар░Хр░░р░┐р░Вр░Ър░Вр░бр░┐", password: "р░кр░╛р░╕р▒Нр░╡р░░р▒Нр░бр▒Н", enter: "р░ир░ор▒Лр░жр▒Б р░Ър▒Зр░пр░Вр░бр░┐", collectorName: "р░╕р▒Зр░Хр░░р░┐р░Вр░Ър▒Зр░╡р░╛р░бр░┐ р░кр▒Зр░░р▒Б", refresh: "р░Ьр░╛р░мр░┐р░др░╛р░ир▒Б р░░р░┐р░лр▒Нр░░р▒Жр░╖р▒Н р░Ър▒Зр░пр░Вр░бр░┐", village: "р░Чр▒Нр░░р░╛р░ор░В", cowBreed: "р░Жр░╡р▒Б р░Ьр░╛р░др░┐", feedType: "р░лр▒Ар░бр▒Н р░░р░Хр░В", moisture: "р░др▒Зр░о р░╕р▒Нр░ер░╛р░пр░┐ (%)", purity: "р░╕р▒Нр░╡р░Ър▒Нр░Ыр░д р░╕р▒Нр░Хр▒Лр░░р▒Б (1-10)" },
    kn: { title: "р▓бр▓Вр▓Чр│НтАМр▓Яр│Нр▓░р│Зр▓╕р│Н", farmer: "р▓░р│Ир▓д", collector: "р▓╕р▓Вр▓Чр│Нр▓░р▓╛р▓╣р▓Х", owner: "р▓ор▓╛р▓▓р│Ар▓Х", addLoad: "р▓╣р│Кр▓╕ р▓▓р│Лр▓бр│Н р▓╕р│Зр▓░р▓┐р▓╕р▓┐", scanFarmerQR: "р▓░р│Ир▓д QR р▓╕р│Нр▓Хр│Нр▓пр▓╛р▓ир│Н р▓ор▓╛р▓бр▓┐", weight: "р▓др│Вр▓Х (р▓Хр│Жр▓Ьр▓┐)", createRecord: "р▓жр▓╛р▓Цр▓▓р│Ж р▓░р▓Ър▓┐р▓╕р▓┐", submitting: "р▓╕р▓▓р│Нр▓▓р▓┐р▓╕р▓▓р▓╛р▓Чр│Бр▓др│Нр▓др▓┐р▓жр│Ж...", pendingCollections: "р▓мр▓╛р▓Хр▓┐ р▓Зр▓░р│Бр▓╡ р▓╕р▓Вр▓Чр│Нр▓░р▓╣р▓Чр▓│р│Б", verifyBatch: "р▓мр│Нр▓пр▓╛р▓Ър│Н р▓кр▓░р▓┐р▓╢р│Ар▓▓р▓┐р▓╕р▓┐", qualityScore: "р▓▓р│Жр▓Хр│Нр▓Хр▓╛р▓Ър▓╛р▓░ р▓ор▓╛р▓бр▓┐р▓ж р▓Чр│Бр▓гр▓ор▓Яр│Нр▓Яр▓ж р▓Ер▓Вр▓Х", updateRecord: "р▓жр▓╛р▓Цр▓▓р│Ж р▓ир▓╡р│Ар▓Хр▓░р▓┐р▓╕р▓┐", password: "р▓кр▓╛р▓╕р│Нр▓╡р▓░р│Нр▓бр│Н", enter: "р▓ир▓ор│Вр▓жр▓┐р▓╕р▓┐", collectorName: "р▓╕р▓Вр▓Чр│Нр▓░р▓╛р▓╣р▓Хр▓░ р▓╣р│Жр▓╕р▓░р│Б", refresh: "р▓кр▓Яр│Нр▓Яр▓┐р▓пр▓ир│Нр▓ир│Б р▓░р▓┐р▓лр│Нр▓░р│Жр▓╢р│Н р▓ор▓╛р▓бр▓┐", village: "р▓Чр│Нр▓░р▓╛р▓о", cowBreed: "р▓╣р▓╕р│Бр▓╡р▓┐р▓и р▓др▓│р▓┐", feedType: "р▓лр│Ар▓бр│Н р▓кр│Нр▓░р▓Хр▓╛р▓░", moisture: "р▓др│Зр▓╡р▓╛р▓Вр▓╢ р▓ор▓Яр│Нр▓Я (%)", purity: "р▓╢р│Бр▓жр│Нр▓зр▓др│Жр▓п р▓Ер▓Вр▓Х (1-10)" }
};

// --- MAIN APP COMPONENT ---
export default function App() {
  const [role, setRole] = useState<string | null>(null);
  const [password, setPassword] = useState<string>("");
  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);
  const [lang, setLang] = useState<'en' | 'ta' | 'hi' | 'te' | 'kn'>('en');
  const t = translations[lang];

  const handleAuth = () => {
      if ((role === 'collector' && password === 'collector123') || (role === 'owner' && password === 'owner123')) {
          setIsAuthenticated(true);
      } else {
          alert("Incorrect Password");
      }
  };

  if (!role) {
      return (
          <div>
              <style>{styles}</style>
              <div className="container">
                  <div className="header">
                      <h1 className="title">ЁЯРо {t.title}</h1>
                  </div>
                  <div className="role-selector">
                      <button className="role-button" onClick={() => setRole('farmer')}>{t.farmer}</button>
                      <button className="role-button" onClick={() => setRole('collector')}>{t.collector}</button>
                      <button className="role-button" onClick={() => setRole('owner')}>{t.owner}</button>
                  </div>
              </div>
          </div>
      );
  }

  if ((role === 'collector' || role === 'owner') && !isAuthenticated) {
      return (
          <div>
              <style>{styles}</style>
              <div className="container">
                  <h2>Enter {role} Password</h2>
                  <input type="password" placeholder={t.password} value={password} onChange={(e) => setPassword(e.target.value)} className="input-field" />
                  <button onClick={handleAuth} className="submit-button">{t.enter}</button>
              </div>
          </div>
      );
  }

  return (
    <div>
      <style>{styles}</style>
      <div className="container">
        <div className="header">
            <h1 className="title">ЁЯРо {t.title}</h1>
        </div>
        <div className="top-bar">
            <div className="nav-buttons">
                <button onClick={() => setRole('farmer')} className={`nav-button ${role === 'farmer' ? 'active' : ''}`}>{t.farmer}</button>
                <button onClick={() => setRole('collector')} className={`nav-button ${role === 'collector' ? 'active' : ''}`}>{t.collector}</button>
                <button onClick={() => setRole('owner')} className={`nav-button ${role === 'owner' ? 'active' : ''}`}>{t.owner}</button>
            </div>
            <select className="lang-select" value={lang} onChange={(e) => setLang(e.target.value as any)}>
                <option value="en">English</option>
                <option value="ta">родрооро┐ро┤рпН (Tamil)</option>
                <option value="hi">рд╣рд┐рдиреНрджреА (Hindi)</option>
                <option value="te">р░др▒Жр░▓р▒Бр░Чр▒Б (Telugu)</option>
                <option value="kn">р▓Хр▓ир│Нр▓ир▓б (Kannada)</option>
            </select>
        </div>
        {role === 'farmer' && <FarmerView t={t} />}
        {role === 'collector' && <CollectorView t={t} />}
        {role === 'owner' && <Dashboard />}
      </div>
    </div>
  );
}

// --- QR SCANNER COMPONENT ---
const QrScannerComponent = ({ onScanSuccess, onScanError }: { onScanSuccess: (text: string) => void, onScanError: (error: any) => void }) => {
    useEffect(() => {
        const scanner = new Html5QrcodeScanner('qr-reader', {
            qrbox: {
                width: 250,
                height: 250,
            },
            fps: 5,
        }, false);

        scanner.render(onScanSuccess, onScanError);

        return () => {
            scanner.clear().catch(error => console.error("Failed to clear scanner.", error));
        };
    }, [onScanSuccess, onScanError]);

    return <div id="qr-reader"></div>;
};


// --- FARMER COMPONENT ---
const FarmerView = ({ t }: { t: any }) => {
    const [isScanning, setIsScanning] = useState(false);
    const [scannedData, setScannedData] = useState<{ id: string, name: string, village: string } | null>(null);
    const [weight, setWeight] = useState("");
    const [cowBreed, setCowBreed] = useState("Gir");
    const [feedType, setFeedType] = useState("Grass-Fed");
    const [status, setStatus] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const [location, setLocation] = useState<{lat: number, lon: number} | null>(null);
    const [mintResult, setMintResult] = useState<{url: string, tokenId: string} | null>(null);

    useEffect(() => {
        navigator.geolocation.getCurrentPosition(
            (pos) => setLocation({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
            () => setStatus("Please enable location.")
        );
    }, []);

    const handleScan = (decodedText: string) => {
        try {
            const farmerInfo = JSON.parse(decodedText);
            if (farmerInfo.id && farmerInfo.name && farmerInfo.village) {
                setScannedData(farmerInfo);
                setIsScanning(false);
            } else {
                throw new Error("QR code has invalid format.");
            }
        } catch (error) {
            setStatus("Invalid Farmer QR Code.");
            setIsScanning(false);
        }
    };

    const handleMint = async () => {
        if (!scannedData || !weight || !location) {
            setStatus("Please scan your ID and enter weight.");
            return;
        }
        setIsLoading(true);
        setStatus(t.submitting);
        setMintResult(null);
        try {
            const response = await fetch('https://cow-dung.onrender.com/mint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ farmerId: scannedData.id, farmerName: scannedData.name, village: scannedData.village, weight, cowBreed, feedType, latitude: location.lat, longitude: location.lon })
            });
            const result = await response.json();
            if (response.ok) {
                setMintResult({url: result.url, tokenId: result.tokenId});
                setScannedData(null); setWeight("");
            } else { throw new Error(result.error); }
        } catch (error: any) {
            setStatus(`тЭМ Error: ${error.message}`);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div className="form-container">
            <h2>{t.addLoad}</h2>
            {!scannedData && !mintResult && (
                <button onClick={() => { setStatus(''); setIsScanning(true); }} className="submit-button">{t.scanFarmerQR}</button>
            )}
            {isScanning && (
                <div className="qr-section">
                    <QrScannerComponent onScanSuccess={handleScan} onScanError={(err: any) => {}} />
                    <button onClick={() => setIsScanning(false)} style={{ marginTop: '1rem' }}>Cancel</button>
                </div>
            )}
            {scannedData && (
                <div>
                    <p><strong>Farmer:</strong> {scannedData.name}, {scannedData.village}</p>
                    <input type="number" placeholder={t.weight} value={weight} onChange={(e) => setWeight(e.target.value)} className="input-field" />
                    <select className="select-field" value={cowBreed} onChange={(e) => setCowBreed(e.target.value)}>
                        <option value="Gir">Gir</option>
                        <option value="Sahiwal">Sahiwal</option>
                    </select>
                    <select className="select-field" value={feedType} onChange={(e) => setFeedType(e.target.value)}>
                        <option value="Grass-Fed">Grass-Fed</option>
                        <option value="Organic">Organic Feed</option>
                    </select>
                    <button onClick={handleMint} disabled={isLoading || !location} className="submit-button">{isLoading ? t.submitting : t.createRecord}</button>
                </div>
            )}
            {status && <p className={`status-message ${status.startsWith('Error') || status.startsWith('Please') ? 'status-error' : 'status-success'}`}>{status}</p>}
            {mintResult && (
                <div className="qr-section">
                    <h3>тЬЕ Batch Registered Successfully!</h3>
                    <p>Please attach this QR Code to the batch.</p>
                    <div style={{ background: 'white', padding: '16px', marginTop: '1rem' }}>
                        <QRCode value={mintResult.tokenId} />
                    </div>
                    <p style={{marginTop: '1rem'}}>
                        <a href={mintResult.url} target="_blank" rel="noopener noreferrer">View Transaction</a>
                    </p>
                    <button onClick={() => setMintResult(null)} style={{marginTop: '1rem'}} className="submit-button">Register Another Batch</button>
                </div>
            )}
        </div>
    );
};

// --- COLLECTOR COMPONENT ---
const CollectorView = ({ t }: { t: any }) => {
    const [pendingBatches, setPendingBatches] = useState<any[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [status, setStatus] = useState("");
    const [isScanning, setIsScanning] = useState(false);
    const [selectedBatch, setSelectedBatch] = useState<any | null>(null);
    const [moisture, setMoisture] = useState("");
    const [purity, setPurity] = useState("");
    const [collectorName, setCollectorName] = useState("");

    const fetchPending = useCallback(async () => {
        setIsLoading(true);
        setStatus("Fetching pending batches...");
        try {
            const response = await fetch('https://cow-dung.onrender.com/get-pending-batches');
            if (!response.ok) throw new Error("Server connection failed.");
            const data = await response.json();
            setPendingBatches(data);
            setStatus(data.length === 0 ? "No pending collections." : "");
        } catch (e: any) {
            setStatus(`тЭМ Error: ${e.message}`);
        } finally {
            setIsLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchPending();
    }, [fetchPending]);

    const calculateQualityScore = () => {
        const moistureNum = parseFloat(moisture);
        const purityNum = parseFloat(purity);
        if (isNaN(moistureNum) || isNaN(purityNum) || moistureNum < 0 || moistureNum > 100 || purityNum < 1 || purityNum > 10) {
            return "Invalid Input";
        }
        const score = (purityNum * 0.7) + ((10 - (moistureNum / 10)) * 0.3);
        return score.toFixed(1);
    };

    const handleUpdate = async () => {
        const qualityScore = calculateQualityScore();
        if (!selectedBatch || qualityScore === "Invalid Input" || !collectorName) {
            setStatus("Please provide valid inputs for all fields.");
            return;
        }
        setIsLoading(true);
        setStatus(t.updating);
        try {
            const response = await fetch('https://cow-dung.onrender.com/update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tokenId: selectedBatch.id, qualityScore, collectorName })
            });
            const result = await response.json();
            if (response.ok) {
                setStatus(`тЬЕ Batch updated successfully!`);
                setSelectedBatch(null); setMoisture(""); setPurity(""); setCollectorName("");
                fetchPending();
            } else { throw new Error(result.error); }
        } catch (error: any) {
            setStatus(`тЭМ Error: ${error.message}`);
        } finally {
            setIsLoading(false);
        }
    };

    if (selectedBatch) {
        return (
            <div className="form-container">
                <h2>{t.verifyBatch}: {selectedBatch.name}</h2>
                <input type="number" placeholder={t.moisture} value={moisture} onChange={(e) => setMoisture(e.target.value)} className="input-field" />
                <input type="number" placeholder={t.purity} value={purity} onChange={(e) => setPurity(e.target.value)} className="input-field" />
                <input type="text" placeholder={t.collectorName} value={collectorName} onChange={(e) => setCollectorName(e.target.value)} className="input-field" />
                <div className="quality-score-display">
                    {t.qualityScore}: {calculateQualityScore()} / 10
                </div>
                <button onClick={handleUpdate} disabled={isLoading} className="submit-button">{isLoading ? t.updating : t.updateRecord}</button>
                <button onClick={() => setSelectedBatch(null)} style={{marginTop: '1rem', backgroundColor: '#6b7280'}} className="submit-button">Back to List</button>
                {status && <p className={`status-message ${status.startsWith('Error') || status.startsWith('Please') ? 'status-error' : 'status-success'}`}>{status}</p>}
            </div>
        );
    }

    return (
        <div className="form-container">
            <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center'}}>
                <h2>{t.pendingCollections}</h2>
                <button onClick={fetchPending} disabled={isLoading} className="submit-button refresh-button" style={{width: 'auto'}}>{t.refresh}</button>
            </div>
            {isLoading && !pendingBatches.length ? <p>Loading...</p> : (
                <ul className="pending-list">
                    {pendingBatches.length > 0 ? pendingBatches.map((batch: any) => (
                        <li key={batch.id} className="pending-item" onClick={() => setSelectedBatch(batch)}>
                            <div>
                                <strong>{batch.name}</strong><br/>
                                <span>Token ID: {batch.id.slice(0, 10)}...</span>
                            </div>
                            <span style={{fontWeight: 600, color: '#f59e0b'}}>PENDING</span>
                        </li>
                    )) : <p>No pending collections found.</p>}
                </ul>
            )}
            {status && <p className={`status-message ${status.startsWith('Error') || status.startsWith('Could') ? 'status-error' : 'status-success'}`}>{status}</p>}
        </div>
    );
};
